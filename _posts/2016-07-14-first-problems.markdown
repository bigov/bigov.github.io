---
layout: post
categories: site content
date: 2016-07-14 01:17:22
title: Первые проблемы
---
Началось. Вчера закончил работу над проектированием базовых классов, необходимых для 
работы графического движка - шейдерная программа, элементы пространства, рендер картинки, 
взаимодействие с пользователем, математика управления камерой. Для проверки всего в 
комплексе сгенерировал поле из 500х500 = 250 000 прямоугольников с текстурой. Соответственно 
- один миллион вершин. Каждый прямоугольник использует отдельный Vertex Array Object (VAO). 
Все значения VAO хранятся в структуре "list"' для покадрового вызова методов отрисовки каждого 
элемента (VAO). Понятно, что ТАК делать нельзя. По крайней мере правильнее будет загружать 
элементы в VBO. Это просто эксперимент для того, чтобы "прощупать" границы возможностей.

То, что картинка формируется около 10 секунд, пока не слишком важно. Более существенно 
резкое ухудшение отзывчивости интерфейса. Вероятная причина - покадровый вызов метода 
"gl::DrawElements" для каждого из 250 тысяч VAO. В рабочем варианте такого количества VAO 
конечно-же использовать нельзя. Тестирование на поиск предельных значений показало, что в 
моей реализации движка встроенный графический модуль Intel успешно обрабатывает до 100 000 
VAO в кадре. При дальнейшем увеличении количества массивов начинает притормаживать 
интерфейс. При значении больше 250 000 VAO на Linux пограмма "падает".

Кроме того, тесты показали что все-таки надо искать способ разделения по потокам обработки 
ввода пользователя и рендер картинки, хотя библиотеки типа SDL2, SFML, да и OpenGL в целом, 
такой возможности в явном виде не предоставляют, но вариатны с обеспечением отзывчивости 
интерфейса во время интенсивной передачи данных в графический буфер все-же есть.

Вторая проблема - загрузка миллиона вершин в графический буфер приводит к тому, что 
программа "выедает" гигабайт оперативки. При этом странно то, что ни размер текстур, ни способ 
хранения значений VAO на размер занятой памяти не влияет. Впрочем, если каждый VAO я храню 
в виде записи в структуре list, то вполне возможно что она и занимает всю оперативку. С этом 
тоже надо разобраться.


